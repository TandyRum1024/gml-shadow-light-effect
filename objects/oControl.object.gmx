<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control object
// window sizes
winW = window_get_width();
winH = window_get_height();

// source surface used to render things into &amp; use for later passes
surfSrc = surface_create(winW, winH);

// highlight surface used to render things with light effect applied
surfLight = surface_create(winW, winH);

// shadow surface used to render shadows
surfShadow = surface_create(winW, winH);

// colour of shadow ($BBGGRR)
shadowColour = $594c52;

// colour of light &amp; intensity
lightColour = $27292b;
lightIntensity = 1;

// ??
time = 0;
displayMode = 0;
depths = ds_priority_create();
/*
    // This block of code was used to spawn a bunch of doggos doing a trance inducing circle dance
    // Uncomment this to unleash the total chaos
    randomize();
    for (var i=0; i&lt;4; i++)
    {
        var _i = instance_create(0, 0, oDog);
        _i.t = (360 / 4) * i;
    }
*/

// shader uniforms
uShadowColour = shader_get_uniform(shd_pass_shadow, "uShadow");
uLightColour = shader_get_uniform(shd_pass_light, "uLight");
uBlurDir = shader_get_uniform(shd_zoom_blur, "uBlurDir");
uPixelSize = shader_get_uniform(shd_zoom_blur, "uPixelSize");

uTest = shader_get_uniform(shd_test, "uTint");

samBlueNoise = shader_get_sampler_index(shd_zoom_blur, "uTexNoise"); // blue noise texture for blur

// set font
draw_set_font(fntMain);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>time++;

if (keyboard_check_pressed(ord("1"))) displayMode = 0;
if (keyboard_check_pressed(ord("2"))) displayMode = 1;
if (keyboard_check_pressed(ord("3"))) displayMode = 2;
if (keyboard_check_pressed(ord("4"))) displayMode = 3;

lightColour = make_colour_hsv(time * 2.5, 255, 255);
lightIntensity = abs(dsin(time * 2.5)) * 0.5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw stuffs into surface
if (!surface_exists(surfSrc)) surfSrc = surface_create(winW, winH);
surface_set_target(surfSrc);
draw_clear_alpha(0, 0);

with (oEffected)
{
    ds_priority_add(other.depths, id, id.depth);
}

while (!ds_priority_empty(depths))
{
    with (ds_priority_delete_max(depths))
    {
        event_user(0);
    }
}
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Compute(??) light &amp; shadow surfaces
if (!surface_exists(surfLight)) surfLight = surface_create(winW, winH); // light buffer
if (!surface_exists(surfShadow)) surfShadow = surface_create(winW, winH); // shadow buffer
var _tmpsurf = surface_create(winW, winH); // temporary buffer to store first blur pass

/// shadow surface
/// draw contents (shadow) onto the shadow buffer
shader_set(shd_pass_shadow);
surface_set_target(surfShadow);

// pass the colour of shadow into the shader
shader_set_uniform_f(uShadowColour, colour_get_red(shadowColour) / 255, colour_get_green(shadowColour) / 255, colour_get_blue(shadowColour) / 255, 1.0);

draw_clear(0);
draw_surface(surfSrc, 0, 0);

surface_reset_target();
shader_reset();

/// apply blur to shadow buffer with temporary surface
shader_set(shd_zoom_blur);
shader_set_uniform_f(uPixelSize, 1 / winW, 1 / winH); // pass the size of single texel into the shader
texture_set_stage(samBlueNoise, sprite_get_texture(texBluenoise64, 0)); // pass blue noise texture

// 1st pass : horizontal blur
shader_set_uniform_f(uBlurDir, 1.0, 0.0); // set blur direction

surface_set_target(_tmpsurf);
draw_clear(0);
draw_surface(surfShadow, 0, 0);
surface_reset_target();

// 2nd pass : vertical blur
shader_set_uniform_f(uBlurDir, 0.0, 1.0); // set blur direction

surface_set_target(surfShadow);
draw_clear(0);
draw_surface(_tmpsurf, 0, 0);
surface_reset_target();

shader_reset();


/// light surface
shader_set(shd_pass_light);
surface_set_target(surfLight);

// pass the colour of light &amp; its intensity into the shader
shader_set_uniform_f(uLightColour, colour_get_red(lightColour) / 255, colour_get_green(lightColour) / 255, colour_get_blue(lightColour) / 255, lightIntensity);

draw_surface(surfSrc, 0, 0);

surface_reset_target();
shader_reset();

// free temp buffer
surface_free(_tmpsurf);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw surfaces
switch (displayMode)
{
    case 0:
        // draw shadow buffer with multiplicative blend mode
        draw_set_blend_mode_ext(bm_zero, bm_src_colour);
        draw_surface(surfShadow, 0, 0);
        
        // draw source buffer with normal blending
        draw_set_blend_mode(bm_normal);
        draw_surface(surfSrc, 0, 0);
        
        // draw light buffer with additive blend mode
        draw_set_blend_mode_ext(bm_one, bm_one);
        draw_surface(surfLight, 0, 0);
        
        // reset blend mode
        draw_set_blend_mode(bm_normal);
        break;
    
    case 1:
        draw_surface(surfLight, 0, 0);
        break;
        
    case 2:
        draw_surface(surfShadow, 0, 0);
        break;
    
    case 3:
        draw_surface(surfSrc, 0, 0);
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw information stuff
var _cx = window_get_width() * 0.5, _cy = window_get_height() * 0.5;

draw_set_halign(1);
draw_text_colour(_cx, 12, "&lt;1-4&gt; : change display mode#[composite, light, shadow, source]", 0, 0, 0, 0, 1);
draw_text_colour(_cx, 10, "&lt;1-4&gt; : change display mode#[composite, light, shadow, source]", c_yellow, c_yellow, c_yellow, c_yellow, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
